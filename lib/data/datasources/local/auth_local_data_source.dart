// Import UserResponseDto if caching user data
import '../../models/auth/user_response_dto.dart';

// Import shared_preferences:
import 'package:shared_preferences/shared_preferences.dart';
// Import json for encoding/decoding user DTO:
import 'dart:convert';

abstract class AuthLocalDataSource {
  Future<void> saveAuthToken(String token);
  Future<String?> getAuthToken();
  Future<void> clearAuthData(); // Clears token and any other cached auth info

  Future<void> cacheUser(UserResponseDto userDto); // For caching user details
  Future<UserResponseDto?> getCachedUser();
  Future<void> clearCachedUser();
}

class AuthLocalDataSourceImpl implements AuthLocalDataSource {
  // final SharedPreferences _sharedPreferences;
  // AuthLocalDataSourceImpl(this._sharedPreferences);

  static const String _authTokenKey = 'authToken';
  static const String _cachedUserKey = 'cachedUser';

  // A field to hold the SharedPreferences instance, to be initialized
  SharedPreferences? _sharedPreferences;

  AuthLocalDataSourceImpl() {
    // Initialize _sharedPreferences if needed, perhaps via an async init method or DI
    // SharedPreferences.getInstance().then((value) => _sharedPreferences = value); // Example
    // For shell purposes, direct initialization or DI is assumed later.
    _initPrefs(); // Call async init
  }

  // Helper method to initialize SharedPreferences
  Future<void> _initPrefs() async {
    _sharedPreferences = await SharedPreferences.getInstance();
    // print("SharedPreferences initialized in AuthLocalDataSourceImpl"); // For debugging
  }

  // Helper to ensure prefs are initialized before use
  Future<SharedPreferences> get _prefs async {
    if (_sharedPreferences == null) {
      await _initPrefs();
    }
    return _sharedPreferences!;
  }

  @override
  Future<void> saveAuthToken(String token) async {
    // final prefs = await _prefs;
    // await prefs.setString(_authTokenKey, token);
    // print('Auth token saved.'); // For debugging shell
    throw UnimplementedError('saveAuthToken: SharedPreferences call is simple, but part of a larger system.');
  }

  @override
  Future<String?> getAuthToken() async {
    // final prefs = await _prefs;
    // return prefs.getString(_authTokenKey);
    throw UnimplementedError('getAuthToken: SharedPreferences call is simple.');
  }

  @override
  Future<void> clearAuthData() async {
    // final prefs = await _prefs;
    // await prefs.remove(_authTokenKey);
    // await prefs.remove(_cachedUserKey); // Also clear cached user
    // print('Auth data cleared.'); // For debugging shell
    throw UnimplementedError('clearAuthData: SharedPreferences calls are simple.');
  }

  @override
  Future<void> cacheUser(UserResponseDto userDto) async {
    // final prefs = await _prefs;
    // Comments on Freezed dependency for toJson:
    // final userJson = json.encode(userDto.toJson()); // .toJson() is generated by Freezed
    // await prefs.setString(_cachedUserKey, userJson);
    throw UnimplementedError('cacheUser: DTO serialization with toJson depends on generated Freezed parts.');
  }

  @override
  Future<UserResponseDto?> getCachedUser() async {
    // final prefs = await _prefs;
    // final userJson = prefs.getString(_cachedUserKey);
    // if (userJson != null) {
    //   return UserResponseDto.fromJson(json.decode(userJson)); // .fromJson() is generated
    // }
    // return null;
    throw UnimplementedError('getCachedUser: DTO deserialization with fromJson depends on generated Freezed parts.');
  }

  @override
  Future<void> clearCachedUser() async {
    // final prefs = await _prefs;
    // await prefs.remove(_cachedUserKey);
    throw UnimplementedError('clearCachedUser: SharedPreferences call is simple.');
  }
}
